package shared

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/cli/cli/v2/internal/ghinstance"
	"github.com/cli/cli/v2/internal/ghrepo"

	graphql "github.com/cli/shurcooL-graphql"
	githubv4 "github.com/shurcooL/githubv4"
)

type VulnerabilityAlert struct {
	Repository struct {
		Name string `json:"name"`
	} `json:"repository"`

	Number                 int                               `json:"number"`
	State                  RepositoryVulnerabilityAlertState `json:"state"`
	SecurityVulnerability  SecurityVulnerability             `json:"securityVulnerability"`
	VulnerableManifestPath string                            `json:"vulnerableManifestPath"`
	VulnerableRequirements string                            `json:"vulnerableRequirements"`
	CreatedAt              time.Time                         `json:"created_at"`
	DismissedAt            time.Time                         `json:"dismissedAt"`
}

type SecurityVulnerability struct {
	Package struct {
		Ecosystem string `json:"ecosystem"`
		Name      string `json:"name"`
	} `json:"package"`

	Advisory Advisory `json:"advisory"`

	Severity Severity `json:"severity"`

	VulnerableVersionRange string `json:"vulnerableVersionRange"`
	FirstPatchedVersion    struct {
		Identifier string `json:"identifier"`
	} `json:"vulnerableVersionRange"`
}

type Advisory struct {
	Identifiers []struct {
		Type  string `json:"type"`
		Value string `json:"value"`
	} `json:"identifiers"`

	CVSS struct {
		Score        float64 `json:"score"`
		VectorString string  `json:"vectorString"`
	}

	GhsaId      string    `json:"ghsaId"`
	Summary     string    `json:"summary"`
	Description string    `json:"description"`
	Permalink   string    `json:"permalink"`
	PublishedAt time.Time `json:"publishedAt"`
	WithdrawnAt time.Time `json:"withdrawnAt"`
}

type RepositoryVulnerabilityAlertState string

func (state RepositoryVulnerabilityAlertState) Color() string {
	switch state {
	case "OPEN":
		return "yellow"
	default:
		return "gray"
	}
}

type Severity int

const (
	UnknownSeverity Severity = iota
	LowSeverity
	ModerateSeverity
	HighSeverity
	CriticalSeverity
)

func (severity *Severity) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}

	switch value {
	case "CRITICAL":
		*severity = CriticalSeverity
	case "HIGH":
		*severity = HighSeverity
	case "MODERATE":
		*severity = ModerateSeverity
	case "LOW":
		*severity = LowSeverity
	default:
		*severity = UnknownSeverity
	}

	return nil
}

func (severity Severity) Color() string {
	switch severity {
	case CriticalSeverity:
		return "magenta"
	case HighSeverity:
		return "red"
	case ModerateSeverity:
		return "yellow"
	case LowSeverity:
		return "green"
	default:
		return "gray"
	}
}

func (severity Severity) String() string {
	switch severity {
	case CriticalSeverity:
		return "Critical"
	case HighSeverity:
		return "High"
	case ModerateSeverity:
		return "Moderate"
	case LowSeverity:
		return "Low"
	default:
		return "Unknown"
	}
}

func FetchOrganizationVulnerabilityAlerts(client *http.Client, repo ghrepo.Interface, org string, state string) ([]VulnerabilityAlert, error) {
	type Repository struct {
		Name  string `json:"name"`
		Owner struct {
			Login string `json:"login"`
		}
		VulnerabilityAlerts struct {
			TotalCount int `json:"totalCount"`
		} `json:"vulnerabilityAlerts"`
	}

	type responseData struct {
		Organization struct {
			Repositories struct {
				Nodes []Repository

				PageInfo struct {
					HasNextPage bool
					EndCursor   string
				}
			} `graphql:"repositories(first: 100, orderBy: {field: NAME, direction: ASC}, after: $endCursor)"`
		} `graphql:"organization(login: $login)"`
	}

	variables := map[string]interface{}{
		"login":     githubv4.String(org),
		"endCursor": (*githubv4.String)(nil),
	}

	gql := graphql.NewClient(ghinstance.GraphQLEndpoint(repo.RepoHost()), client)

	var repositories []Repository
	for {
		var query responseData
		err := gql.QueryNamed(context.Background(), "VulnerabilityAlerts", &query, variables)
		if err != nil {
			return nil, err
		}

		for _, repository := range query.Organization.Repositories.Nodes {
			if repository.VulnerabilityAlerts.TotalCount > 0 {
				repositories = append(repositories, repository)
			}
		}

		if !query.Organization.Repositories.PageInfo.HasNextPage {
			break
		}
		variables["endCursor"] = githubv4.String(query.Organization.Repositories.PageInfo.EndCursor)
	}

	var alerts []VulnerabilityAlert
	for _, repository := range repositories {
		r := ghrepo.NewWithHost(repository.Owner.Login, repository.Name, repo.RepoHost())
		fetched, err := FetchRepositoryVulnerabilityAlerts(client, r, state)
		if err != nil {
			return nil, err
		}
		alerts = append(alerts, fetched...)
	}

	return alerts, nil
}

type responseData struct {
	Repository struct {
		VulnerabilityAlerts struct {
			Nodes []VulnerabilityAlert

			PageInfo struct {
				HasNextPage bool
				EndCursor   string
			}
		} `graphql:"vulnerabilityAlerts(states: $states, first: 100, after: $endCursor)"`
	} `graphql:"repository(owner: $owner, name: $name)"`
}

func FetchRepositoryVulnerabilityAlerts(client *http.Client, repo ghrepo.Interface, state string) ([]VulnerabilityAlert, error) {
	var states []RepositoryVulnerabilityAlertState
	switch state {
	case "dismissed":
		states = []RepositoryVulnerabilityAlertState{"DISMISSED"}
	case "fixed":
		states = []RepositoryVulnerabilityAlertState{"FIXED"}
	case "open":
		states = []RepositoryVulnerabilityAlertState{"OPEN"}
	case "all":
		states = []RepositoryVulnerabilityAlertState{"DISMISSED", "FIXED", "OPEN"}
	default:
		return nil, fmt.Errorf("invalid state: %s", state)
	}

	variables := map[string]interface{}{
		"owner":     githubv4.String(repo.RepoOwner()),
		"name":      githubv4.String(repo.RepoName()),
		"states":    states,
		"endCursor": (*githubv4.String)(nil),
	}

	gql := graphql.NewClient(ghinstance.GraphQLEndpoint(repo.RepoHost()), client)

	var alerts []VulnerabilityAlert
	for {
		var query responseData
		err := gql.QueryNamed(context.Background(), "VulnerabilityAlerts", &query, variables)
		if err != nil {
			return nil, err
		}

		alerts = append(alerts, query.Repository.VulnerabilityAlerts.Nodes...)
		if !query.Repository.VulnerabilityAlerts.PageInfo.HasNextPage {
			break
		}
		variables["endCursor"] = githubv4.String(query.Repository.VulnerabilityAlerts.PageInfo.EndCursor)
	}

	return alerts, nil
}

func FetchRepositoryAlertWithMatcher(client *http.Client, repo ghrepo.Interface, match func(VulnerabilityAlert) bool) (*VulnerabilityAlert, error) {
	variables := map[string]interface{}{
		"owner":     githubv4.String(repo.RepoOwner()),
		"name":      githubv4.String(repo.RepoName()),
		"states":    []RepositoryVulnerabilityAlertState{"DISMISSED", "FIXED", "OPEN"},
		"endCursor": (*githubv4.String)(nil),
	}

	gql := graphql.NewClient(ghinstance.GraphQLEndpoint(repo.RepoHost()), client)

	for {
		var query responseData
		err := gql.QueryNamed(context.Background(), "VulnerabilityAlerts", &query, variables)
		if err != nil {
			return nil, err
		}

		for _, alert := range query.Repository.VulnerabilityAlerts.Nodes {
			if match(alert) {
				return &alert, nil
			}
		}

		if !query.Repository.VulnerabilityAlerts.PageInfo.HasNextPage {
			break
		}
		variables["endCursor"] = githubv4.String(query.Repository.VulnerabilityAlerts.PageInfo.EndCursor)
	}

	return nil, nil
}
