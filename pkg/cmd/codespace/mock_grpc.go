// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package codespace

import (
	"context"
	"sync"

	"github.com/cli/cli/v2/internal/codespaces/grpc"
)

// GrpcClientMock is a mock implementation of GrpcClient.
//
// 	func TestSomethingThatUsesGrpcClient(t *testing.T) {
//
// 		// make and configure a mocked GrpcClient
// 		mockedGrpcClient := &GrpcClientMock{
// 			ConnectFunc: func(ctx context.Context, port int, token string) error {
// 				panic("mock out the Connect method")
// 			},
// 			GetRunningServerFunc: func() (int, string, error) {
// 				panic("mock out the GetRunningServer method")
// 			},
// 			KeepAliveFunc: func(s string)  {
// 				panic("mock out the KeepAlive method")
// 			},
// 			StartRemoteServerFunc: func(options grpc.StartSSHServerOptions) (int, string, error) {
// 				panic("mock out the StartRemoteServer method")
// 			},
// 		}
//
// 		// use mockedGrpcClient in code that requires GrpcClient
// 		// and then make assertions.
//
// 	}
type GrpcClientMock struct {
	// ConnectFunc mocks the Connect method.
	ConnectFunc func(ctx context.Context, port int, token string) error

	// GetRunningServerFunc mocks the GetRunningServer method.
	GetRunningServerFunc func() (int, string, error)

	// KeepAliveFunc mocks the KeepAlive method.
	KeepAliveFunc func(s string)

	// StartRemoteServerFunc mocks the StartRemoteServer method.
	StartRemoteServerFunc func(options grpc.StartSSHServerOptions) (int, string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Connect holds details about calls to the Connect method.
		Connect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Port is the port argument value.
			Port int
			// Token is the token argument value.
			Token string
		}
		// GetRunningServer holds details about calls to the GetRunningServer method.
		GetRunningServer []struct {
		}
		// KeepAlive holds details about calls to the KeepAlive method.
		KeepAlive []struct {
			// S is the s argument value.
			S string
		}
		// StartRemoteServer holds details about calls to the StartRemoteServer method.
		StartRemoteServer []struct {
			// Options is the options argument value.
			Options grpc.StartSSHServerOptions
		}
	}
	lockConnect           sync.RWMutex
	lockGetRunningServer  sync.RWMutex
	lockKeepAlive         sync.RWMutex
	lockStartRemoteServer sync.RWMutex
}

// Connect calls ConnectFunc.
func (mock *GrpcClientMock) Connect(ctx context.Context, port int, token string) error {
	if mock.ConnectFunc == nil {
		panic("GrpcClientMock.ConnectFunc: method is nil but GrpcClient.Connect was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Port  int
		Token string
	}{
		Ctx:   ctx,
		Port:  port,
		Token: token,
	}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc(ctx, port, token)
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//     len(mockedGrpcClient.ConnectCalls())
func (mock *GrpcClientMock) ConnectCalls() []struct {
	Ctx   context.Context
	Port  int
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Port  int
		Token string
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// GetRunningServer calls GetRunningServerFunc.
func (mock *GrpcClientMock) GetRunningServer() (int, string, error) {
	if mock.GetRunningServerFunc == nil {
		panic("GrpcClientMock.GetRunningServerFunc: method is nil but GrpcClient.GetRunningServer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetRunningServer.Lock()
	mock.calls.GetRunningServer = append(mock.calls.GetRunningServer, callInfo)
	mock.lockGetRunningServer.Unlock()
	return mock.GetRunningServerFunc()
}

// GetRunningServerCalls gets all the calls that were made to GetRunningServer.
// Check the length with:
//     len(mockedGrpcClient.GetRunningServerCalls())
func (mock *GrpcClientMock) GetRunningServerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetRunningServer.RLock()
	calls = mock.calls.GetRunningServer
	mock.lockGetRunningServer.RUnlock()
	return calls
}

// KeepAlive calls KeepAliveFunc.
func (mock *GrpcClientMock) KeepAlive(s string) {
	if mock.KeepAliveFunc == nil {
		panic("GrpcClientMock.KeepAliveFunc: method is nil but GrpcClient.KeepAlive was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockKeepAlive.Lock()
	mock.calls.KeepAlive = append(mock.calls.KeepAlive, callInfo)
	mock.lockKeepAlive.Unlock()
	mock.KeepAliveFunc(s)
}

// KeepAliveCalls gets all the calls that were made to KeepAlive.
// Check the length with:
//     len(mockedGrpcClient.KeepAliveCalls())
func (mock *GrpcClientMock) KeepAliveCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockKeepAlive.RLock()
	calls = mock.calls.KeepAlive
	mock.lockKeepAlive.RUnlock()
	return calls
}

// StartRemoteServer calls StartRemoteServerFunc.
func (mock *GrpcClientMock) StartRemoteServer(options grpc.StartSSHServerOptions) (int, string, error) {
	if mock.StartRemoteServerFunc == nil {
		panic("GrpcClientMock.StartRemoteServerFunc: method is nil but GrpcClient.StartRemoteServer was just called")
	}
	callInfo := struct {
		Options grpc.StartSSHServerOptions
	}{
		Options: options,
	}
	mock.lockStartRemoteServer.Lock()
	mock.calls.StartRemoteServer = append(mock.calls.StartRemoteServer, callInfo)
	mock.lockStartRemoteServer.Unlock()
	return mock.StartRemoteServerFunc(options)
}

// StartRemoteServerCalls gets all the calls that were made to StartRemoteServer.
// Check the length with:
//     len(mockedGrpcClient.StartRemoteServerCalls())
func (mock *GrpcClientMock) StartRemoteServerCalls() []struct {
	Options grpc.StartSSHServerOptions
} {
	var calls []struct {
		Options grpc.StartSSHServerOptions
	}
	mock.lockStartRemoteServer.RLock()
	calls = mock.calls.StartRemoteServer
	mock.lockStartRemoteServer.RUnlock()
	return calls
}
